"""
End-to-End Vulnerability Remediation Pipeline

This script orchestrates the entire DevSecOps workflow:
1.  (Assumes a vulnerability report already exists)
2.  Parses the vulnerability report.
3.  Uses the github-client to create GitHub issues for each finding.
4.  Clones the target repository.
5.  Initializes the ScoutAgent and TriageAgent.
6.  Loops through the findings and instructs the TriageAgent to fix them.
7.  The TriageAgent commits the fix to a new branch.
8.  Uses the github-client to create a pull request for the fix.
"""

import os
import shutil
import logging
import time
import subprocess
from git import Repo
from collections import defaultdict
from git.exc import GitCommandError

# Corrected local module imports to reflect the new package structure
from scout_agent.scout_agent import ScoutAgent
from scout_agent.triage_agent import TriageAgent
from scout_agent.shared_types import Finding
from vscanner.report_parser import ReportParser
from vscanner.vulnerability_scanner import generate_report
from github_client.github_integration import create_github_integration

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- Configuration ---
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
# The repository to clone and fix
GITHUB_REPO_NAME = "tads-demo/repo_demo" # Updated to the new test repo
LOCAL_REPO_PATH = "temp_vulnerable_repo"
REPORT_FILE = "vulnerability_report.text" # This will be the output path

def main():
    """Main function to run the remediation pipeline."""
    if not GITHUB_TOKEN:
        logger.error("GITHUB_TOKEN environment variable not set. Aborting.")
        return

    # Initialize GitHub client
    try:
        gh = create_github_integration()
        logger.info(f"Successfully connected to GitHub as: {gh.user.login}")
    except Exception as e:
        logger.error(f"Failed to initialize GitHub client: {e}")
        return

    # 3. Clone the repository
    logger.info(f"Cloning repository '{GITHUB_REPO_NAME}' into '{LOCAL_REPO_PATH}'...")
    if os.path.exists(LOCAL_REPO_PATH):
        shutil.rmtree(LOCAL_REPO_PATH)
    repo = Repo.clone_from(f"https://{GITHUB_TOKEN}@github.com/{GITHUB_REPO_NAME}.git", LOCAL_REPO_PATH)
    logger.info("Repository cloned successfully.")

    # 2. Generate a vulnerability report by scanning the *cloned* repo
    logger.info(f"Scanning the cloned repository at '{LOCAL_REPO_PATH}'...")
    report_output_path = os.path.join(os.getcwd(), "vulnerability_report.text") # Save report in main dir
    generate_report(LOCAL_REPO_PATH, report_output_path)
    
    try:
        # 3. Parse the newly generated vulnerability report
        logger.info(f"Parsing vulnerability report: {report_output_path}")
        parser = ReportParser()
        findings = parser.parse(report_output_path)
        if not findings:
            logger.info("No findings in the report. Exiting.")
            return

        # 3. Create GitHub issues for each finding
        logger.info("Creating GitHub issues for each finding...")
        for finding in findings:
            try:
                issue = gh.create_issue(
                    repo_name=GITHUB_REPO_NAME,
                    title=f"Vulnerability: {finding.type} in {finding.file_path}",
                    body=f"**Severity:** {finding.severity}\n**File:** `{finding.file_path}` (Line: {finding.line_number})\n**Description:** {finding.message}\n**Evidence:**\n```\n{finding.evidence}\n```",
                    labels=["bug", "security", "autogenerated"]
                )
                finding.issue_number = issue.number
                logger.info(f"Created issue #{issue.number} for finding {finding.id}")
            except Exception as e:
                logger.error(f"Failed to create issue for finding {finding.id}: {e}")
        
        # Filter out findings for which we couldn't create an issue
        findings_with_issues = [f for f in findings if f.issue_number is not None]

        # Group findings by vulnerability type
        grouped_findings = defaultdict(list)
        for finding in findings_with_issues:
            grouped_findings[finding.type].append(finding)
        logger.info(f"Grouped findings into {len(grouped_findings)} topics.")

        # 4. Initialize Agents and process topics
        scout = ScoutAgent()
        triage = TriageAgent(scout_agent=scout, target_directory=LOCAL_REPO_PATH)

        # 5. Loop through each vulnerability topic and create a PR
        for vuln_type, findings_in_group in grouped_findings.items():
            logger.info(f"--- Processing topic: {vuln_type} ({len(findings_in_group)} findings) ---")
            branch_name = f"fix/{vuln_type.replace(' ', '_').lower()}"
            
            try:
                # Branching, fixing, pushing, and PR creation logic...
                logger.info(f"Creating branch '{branch_name}'...")
                if branch_name in repo.heads:
                    repo.delete_head(branch_name, '-D')
                repo.create_head(branch_name).checkout()

                successful_commits = 0
                for finding in findings_in_group:
                    if triage.remediate_and_commit(finding):
                        successful_commits += 1
                
                # Only proceed if we have something to push
                if successful_commits > 0:
                    # --- Retry Logic for Push & PR Creation ---
                    MAX_RETRIES = 3
                    RETRY_DELAY_SECONDS = 5
                    for attempt in range(MAX_RETRIES):
                        try:
                            logger.info(f"Attempt {attempt + 1}/{MAX_RETRIES}: Pushing branch '{branch_name}' via subprocess...")
                            
                            # Use subprocess to get more detailed error output from command-line Git
                            # Using --force to overwrite the branch if it exists from a previous failed run
                            process = subprocess.run(
                                ["git", "push", "origin", branch_name, "--force"],
                                cwd=LOCAL_REPO_PATH,
                                capture_output=True,
                                text=True,
                                check=True  # Will raise CalledProcessError on non-zero exit code
                            )
                            logger.info(f"Branch '{branch_name}' pushed successfully.")

                            issue_numbers = [f"#{f.issue_number}" for f in findings_in_group if f.issue_number]
                            pr_body = f"This PR automatically remediates {successful_commits} vulnerabilities of type `{vuln_type}`.\n\nCloses: {', '.join(issue_numbers)}"
                            
                            pr = gh.create_pull_request(
                                repo_name=GITHUB_REPO_NAME,
                                title=f"Fix: Remediate {vuln_type} vulnerabilities",
                                body=pr_body,
                                head=branch_name,
                                base="main"
                            )
                            logger.info(f"Successfully created Pull Request for topic '{vuln_type}': {pr.html_url}")
                            break # Success, exit retry loop
                        
                        except subprocess.CalledProcessError as e:
                            logger.warning(f"Git push command failed on attempt {attempt + 1}.")
                            logger.warning(f"Stderr: {e.stderr.strip()}")
                            if attempt < MAX_RETRIES - 1:
                                logger.info(f"Retrying in {RETRY_DELAY_SECONDS} seconds...")
                                time.sleep(RETRY_DELAY_SECONDS)
                            else:
                                logger.error(f"All {MAX_RETRIES} push attempts failed for topic '{vuln_type}'.")
                                raise e # Re-raise to be caught by the outer block
                        except Exception as e:
                            logger.warning(f"Attempt {attempt + 1} failed: {e}")
                            if attempt < MAX_RETRIES - 1:
                                logger.info(f"Retrying in {RETRY_DELAY_SECONDS} seconds...")
                                time.sleep(RETRY_DELAY_SECONDS)
                            else:
                                logger.error(f"All {MAX_RETRIES} attempts failed for topic '{vuln_type}'.")
                                raise
                else:
                    logger.warning(f"No successful commits for topic '{vuln_type}'. Skipping PR creation.")

            except Exception as e:
                logger.error(f"Failed to process topic '{vuln_type}': {e}")
            finally:
                # Return to main branch to prepare for the next topic
                repo.git.checkout('main')
    
    finally:
        # 6. Clean up the local repository and report file
        if os.path.exists(LOCAL_REPO_PATH):
            shutil.rmtree(LOCAL_REPO_PATH)
            logger.info(f"Cleaned up local repository: {LOCAL_REPO_PATH}")
        if os.path.exists(report_output_path):
            os.remove(report_output_path)
            logger.info(f"Cleaned up report file: {report_output_path}")

if __name__ == "__main__":
    main()
