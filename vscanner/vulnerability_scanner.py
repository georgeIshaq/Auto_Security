"""
Vulnerability Scanner

This module contains the core logic for scanning a codebase for vulnerabilities
and generating a structured report.
"""

import os
import re
import logging
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Simplified vulnerability patterns for demonstration
VULNERABILITY_PATTERNS = {
    'HARDCODED_SECRETS': [
        r"(password\s*[:=]\s*['\"].+['\"])",
        r"(api_key\s*[:=]\s*['\"].+['\"])",
        r"(secret_key\s*[:=]\s*['\"].+['\"])",
    ],
    'COMMAND_INJECTION': [
        r"exec\(`",
        r"os\.system\("
    ]
}

def scan_directory(directory: str) -> list:
    """Scans a directory for vulnerabilities based on predefined patterns."""
    findings = []
    finding_id_counter = 1
    for root, _, files in os.walk(directory):
        for file in files:
            file_path = os.path.join(root, file)
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    for line_num, line in enumerate(f, 1):
                        for vuln_type, patterns in VULNERABILITY_PATTERNS.items():
                            for pattern in patterns:
                                match = re.search(pattern, line)
                                if match:
                                    findings.append({
                                        'id': finding_id_counter,
                                        'type': vuln_type,
                                        'file_path': os.path.relpath(file_path, directory),
                                        'line_number': line_num,
                                        'evidence': line.strip()
                                    })
                                    finding_id_counter += 1
            except Exception as e:
                logger.warning(f"Could not read file {file_path}: {e}")
    return findings

def generate_report(target_directory: str, output_path: str):
    """
    Scans a directory and generates a vulnerability_report.text file.
    
    :param target_directory: The directory to scan.
    :param output_path: The path to write the report to.
    """
    logger.info(f"Starting vulnerability scan on directory: {target_directory}")
    findings = scan_directory(target_directory)
    
    report_content = f"""================================================================================
VULNERABILITY SCAN REPORT
================================================================================
Scan ID: scan_{int(datetime.now().timestamp())}
Target: {target_directory}
Timestamp: {datetime.now().isoformat()}
Total Findings: {len(findings)}

DETAILED FINDINGS:
----------------------------------------
"""
    for finding in findings:
        report_content += f"""
{finding['id']}. {finding['type']} - CRITICAL
   File: ./{finding['file_path']}:{finding['line_number']}
   Confidence: 0.98
   Description: {finding['type'].replace('_', ' ').title()} detected.
   Evidence: {finding['evidence']}
"""
    with open(output_path, 'w') as f:
        f.write(report_content)
        
    logger.info(f"Vulnerability report generated successfully at: {output_path}")

if __name__ == '__main__':
    # Example usage: Scan the ../repo_demo directory and generate a report
    # This assumes the script is run from inside the vscanner directory
    if not os.path.exists("../repo_demo"):
        print("Error: The ../repo_demo directory does not exist. Please create it for the test.")
    else:
        generate_report("../repo_demo", "vulnerability_report.text")
        print("Scan complete. Report generated in vscanner/vulnerability_report.text")
