"""
Vulnerability Scanner - Detects security vulnerabilities in codebases

This scanner integrates with the Scout Agent to provide context-aware vulnerability detection
using vector similarity search for enhanced threat intelligence.
"""

import os
import re
import json
import ast
import logging
from datetime import datetime
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass, asdict
from pathlib import Path

import requests
from bs4 import BeautifulSoup

# Import Scout Agent for vulnerability context
from scout_agent import ScoutAgent, VulnerabilityData

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class VulnerabilityFinding:
    """Structure for vulnerability findings"""
    finding_id: str
    vulnerability_type: str
    severity: str
    confidence: float
    file_path: str
    line_number: int
    code_snippet: str
    description: str
    evidence: str
    cve_matches: List[Dict] = None
    suggested_patches: List[Dict] = None
    remediation_priority: int = 0

@dataclass
class ScanResult:
    """Structure for scan results"""
    scan_id: str
    target_path: str
    scan_timestamp: str
    total_findings: int
    findings_by_severity: Dict[str, int]
    findings: List[VulnerabilityFinding]
    scan_duration: float

class VulnerabilityScanner:
    """
    Advanced vulnerability scanner with AI-powered context awareness
    """
    
    def __init__(self, scout_agent: ScoutAgent = None):
        """Initialize the vulnerability scanner"""
        self.scout_agent = scout_agent or ScoutAgent()
        
        # Vulnerability patterns for different languages
        self.patterns = {
            'javascript': {
                'sql_injection': [
                    r'query\s*\(\s*["\'].*\$.*["\']',  # String interpolation in queries
                    r'SELECT.*\+.*req\.',  # String concatenation in SQL
                    r'INSERT.*\+.*req\.',  # String concatenation in SQL
                    r'UPDATE.*\+.*req\.',  # String concatenation in SQL
                    r'DELETE.*\+.*req\.',  # String concatenation in SQL
                ],
                'xss': [
                    r'dangerouslySetInnerHTML',  # React XSS
                    r'innerHTML\s*=',  # Direct innerHTML assignment
                    r'document\.write\s*\(',  # document.write usage
                    r'eval\s*\(',  # eval() usage
                ],
                'command_injection': [
                    r'exec\s*\(',  # exec() usage
                    r'spawn\s*\(',  # spawn with user input
                    r'execSync\s*\(',  # execSync usage
                    r'shell\s*:\s*true',  # shell: true in child_process
                ],
                'path_traversal': [
                    r'fs\.readFile\s*\(.*req\.',  # File read with user input
                    r'fs\.createReadStream\s*\(.*req\.',  # File stream with user input
                    r'path\.join\s*\(.*req\.',  # Path join with user input
                ],
                'hardcoded_secrets': [
                    r'password\s*[:=]\s*["\'][^"\']{3,}["\']',  # Hardcoded passwords
                    r'api[_-]?key\s*[:=]\s*["\'][^"\']{10,}["\']',  # API keys
                    r'secret\s*[:=]\s*["\'][^"\']{10,}["\']',  # Secrets
                    r'token\s*[:=]\s*["\'][^"\']{10,}["\']',  # Tokens
                ],
                'insecure_random': [
                    r'Math\.random\s*\(',  # Math.random for security
                    r'crypto\.randomBytes\s*\(.*1\)',  # Insufficient random bytes
                ],
                'weak_crypto': [
                    r'crypto\.createHash\s*\(\s*["\']md5["\']',  # MD5 usage
                    r'crypto\.createHash\s*\(\s*["\']sha1["\']',  # SHA1 usage
                ]
            },
            'python': {
                'sql_injection': [
                    r'execute\s*\(\s*f["\'].*\{.*\}.*["\']',  # f-string in SQL
                    r'execute\s*\(\s*["\'].*%s.*["\']',  # String formatting in SQL
                    r'query\s*\(\s*["\'].*\+.*["\']',  # String concatenation
                ],
                'command_injection': [
                    r'os\.system\s*\(',  # os.system usage
                    r'subprocess\.call\s*\(.*shell\s*=\s*True',  # subprocess with shell
                    r'eval\s*\(',  # eval() usage
                    r'exec\s*\(',  # exec() usage
                ],
                'path_traversal': [
                    r'open\s*\(.*input',  # File open with user input
                    r'file\s*\(.*input',  # File with user input
                ],
                'deserialization': [
                    r'pickle\.loads\s*\(',  # Pickle deserialization
                    r'yaml\.load\s*\(',  # YAML load without safe_load
                ],
                'hardcoded_secrets': [
                    r'password\s*=\s*["\'][^"\']{3,}["\']',  # Hardcoded passwords
                    r'api_key\s*=\s*["\'][^"\']{10,}["\']',  # API keys
                    r'secret\s*=\s*["\'][^"\']{10,}["\']',  # Secrets
                ]
            }
        }
        
        # Severity mapping
        self.severity_map = {
            'sql_injection': 'HIGH',
            'xss': 'MEDIUM',
            'command_injection': 'CRITICAL',
            'path_traversal': 'HIGH',
            'hardcoded_secrets': 'CRITICAL',
            'insecure_random': 'MEDIUM',
            'weak_crypto': 'MEDIUM',
            'deserialization': 'HIGH'
        }
        
        # Confidence scoring based on pattern strength
        self.confidence_map = {
            'sql_injection': 0.9,
            'command_injection': 0.95,
            'path_traversal': 0.85,
            'hardcoded_secrets': 0.98,
            'xss': 0.8,
            'insecure_random': 0.7,
            'weak_crypto': 0.75,
            'deserialization': 0.9
        }

    def detect_vulnerabilities_in_file(self, file_path: str, content: str) -> List[VulnerabilityFinding]:
        """
        Detect vulnerabilities in a single file
        """
        findings = []
        file_extension = Path(file_path).suffix.lower()
        
        # Determine language based on file extension
        language = None
        if file_extension in ['.js', '.jsx', '.ts', '.tsx']:
            language = 'javascript'
        elif file_extension in ['.py']:
            language = 'python'
        else:
            logger.warning(f"Unsupported file type: {file_extension}")
            return findings
        
        if language not in self.patterns:
            return findings
        
        lines = content.split('\n')
        
        # Check each vulnerability pattern
        for vuln_type, patterns in self.patterns[language].items():
            for pattern in patterns:
                try:
                    regex = re.compile(pattern, re.IGNORECASE | re.MULTILINE)
                    matches = regex.finditer(content)
                    
                    for match in matches:
                        # Find line number
                        line_num = content[:match.start()].count('\n') + 1
                        
                        # Get code snippet (3 lines before and after)
                        start_line = max(0, line_num - 4)
                        end_line = min(len(lines), line_num + 3)
                        code_snippet = '\n'.join(lines[start_line:end_line])
                        
                        # Create finding
                        finding = VulnerabilityFinding(
                            finding_id=f"{Path(file_path).stem}_{vuln_type}_{line_num}_{hash(match.group())}",
                            vulnerability_type=vuln_type,
                            severity=self.severity_map.get(vuln_type, 'MEDIUM'),
                            confidence=self.confidence_map.get(vuln_type, 0.8),
                            file_path=file_path,
                            line_number=line_num,
                            code_snippet=code_snippet,
                            description=self._get_vulnerability_description(vuln_type),
                            evidence=match.group()
                        )
                        
                        # Get AI context if scout agent is available
                        if self.scout_agent:
                            finding.cve_matches = self._get_cve_context(vuln_type, language)
                            finding.suggested_patches = self._get_suggested_patches(vuln_type, language)
                        
                        findings.append(finding)
                        
                except re.error as e:
                    logger.error(f"Regex error in pattern {pattern}: {e}")
                    continue
        
        return findings

    def _get_vulnerability_description(self, vuln_type: str) -> str:
        """Get human-readable description for vulnerability type"""
        descriptions = {
            'sql_injection': 'SQL Injection vulnerability detected - user input directly concatenated into SQL queries',
            'xss': 'Cross-Site Scripting (XSS) vulnerability detected - unsanitized user input rendered in HTML',
            'command_injection': 'Command Injection vulnerability detected - user input passed to system commands',
            'path_traversal': 'Path Traversal vulnerability detected - user input used in file path operations',
            'hardcoded_secrets': 'Hardcoded secrets detected - sensitive credentials stored in source code',
            'insecure_random': 'Insecure random number generation detected - insufficient entropy for security purposes',
            'weak_crypto': 'Weak cryptographic algorithm detected - deprecated or insecure hash functions used',
            'deserialization': 'Unsafe deserialization detected - potential for arbitrary code execution'
        }
        return descriptions.get(vuln_type, f'{vuln_type} vulnerability detected')

    def _get_cve_context(self, vuln_type: str, language: str) -> List[Dict]:
        """Get CVE context from Scout Agent"""
        try:
            query = f"{vuln_type} vulnerability in {language}"
            return self.scout_agent.find_similar_vulnerabilities(query, k=3)
        except Exception as e:
            logger.error(f"Failed to get CVE context: {e}")
            return []

    def _get_suggested_patches(self, vuln_type: str, language: str) -> List[Dict]:
        """Get suggested patches from Scout Agent"""
        try:
            return self.scout_agent.find_proven_patches(vuln_type, language=language, k=2)
        except Exception as e:
            logger.error(f"Failed to get suggested patches: {e}")
            return []

    def scan_directory(self, target_path: str, file_extensions: List[str] = None) -> ScanResult:
        """
        Scan a directory for vulnerabilities
        """
        start_time = datetime.now()
        scan_id = f"scan_{int(start_time.timestamp())}"
        
        if file_extensions is None:
            file_extensions = ['.js', '.jsx', '.ts', '.tsx', '.py']
        
        all_findings = []
        files_scanned = 0
        
        logger.info(f"Starting vulnerability scan of {target_path}")
        
        for root, dirs, files in os.walk(target_path):
            # Skip common directories that shouldn't be scanned
            dirs[:] = [d for d in dirs if d not in ['.git', 'node_modules', '__pycache__', '.venv', 'venv']]
            
            for file in files:
                file_path = os.path.join(root, file)
                file_ext = Path(file_path).suffix.lower()
                
                if file_ext in file_extensions:
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                        
                        findings = self.detect_vulnerabilities_in_file(file_path, content)
                        all_findings.extend(findings)
                        files_scanned += 1
                        
                        if findings:
                            logger.info(f"Found {len(findings)} vulnerabilities in {file_path}")
                            
                    except Exception as e:
                        logger.error(f"Error scanning {file_path}: {e}")
                        continue
        
        # Calculate scan duration
        end_time = datetime.now()
        scan_duration = (end_time - start_time).total_seconds()
        
        # Count findings by severity
        findings_by_severity = {}
        for finding in all_findings:
            severity = finding.severity
            findings_by_severity[severity] = findings_by_severity.get(severity, 0) + 1
        
        # Calculate remediation priority
        for finding in all_findings:
            finding.remediation_priority = self._calculate_priority(finding)
        
        # Sort findings by priority
        all_findings.sort(key=lambda x: x.remediation_priority, reverse=True)
        
        result = ScanResult(
            scan_id=scan_id,
            target_path=target_path,
            scan_timestamp=start_time.isoformat(),
            total_findings=len(all_findings),
            findings_by_severity=findings_by_severity,
            findings=all_findings,
            scan_duration=scan_duration
        )
        
        logger.info(f"Scan completed: {len(all_findings)} findings in {files_scanned} files ({scan_duration:.2f}s)")
        return result

    def _calculate_priority(self, finding: VulnerabilityFinding) -> int:
        """Calculate remediation priority based on severity and confidence"""
        severity_weights = {
            'CRITICAL': 100,
            'HIGH': 75,
            'MEDIUM': 50,
            'LOW': 25
        }
        
        base_priority = severity_weights.get(finding.severity, 50)
        confidence_boost = int(finding.confidence * 20)
        
        return base_priority + confidence_boost

    def generate_report(self, scan_result: ScanResult, output_format: str = 'json') -> str:
        """
        Generate vulnerability report in specified format
        """
        if output_format == 'json':
            return self._generate_json_report(scan_result)
        elif output_format == 'html':
            return self._generate_html_report(scan_result)
        elif output_format == 'text':
            return self._generate_text_report(scan_result)
        else:
            raise ValueError(f"Unsupported output format: {output_format}")

    def _generate_json_report(self, scan_result: ScanResult) -> str:
        """Generate JSON report"""
        report_data = {
            'scan_metadata': {
                'scan_id': scan_result.scan_id,
                'target_path': scan_result.target_path,
                'scan_timestamp': scan_result.scan_timestamp,
                'scan_duration': scan_result.scan_duration,
                'total_findings': scan_result.total_findings,
                'findings_by_severity': scan_result.findings_by_severity
            },
            'findings': [asdict(finding) for finding in scan_result.findings]
        }
        return json.dumps(report_data, indent=2)

    def _generate_text_report(self, scan_result: ScanResult) -> str:
        """Generate text report"""
        report = []
        report.append("=" * 80)
        report.append("VULNERABILITY SCAN REPORT")
        report.append("=" * 80)
        report.append(f"Scan ID: {scan_result.scan_id}")
        report.append(f"Target: {scan_result.target_path}")
        report.append(f"Timestamp: {scan_result.scan_timestamp}")
        report.append(f"Duration: {scan_result.scan_duration:.2f} seconds")
        report.append(f"Total Findings: {scan_result.total_findings}")
        report.append("")
        
        # Summary by severity
        report.append("SUMMARY BY SEVERITY:")
        report.append("-" * 40)
        for severity, count in scan_result.findings_by_severity.items():
            report.append(f"{severity:>10}: {count:>3} findings")
        report.append("")
        
        # Detailed findings
        report.append("DETAILED FINDINGS:")
        report.append("-" * 40)
        
        for i, finding in enumerate(scan_result.findings, 1):
            report.append(f"\n{i}. {finding.vulnerability_type.upper()} - {finding.severity}")
            report.append(f"   File: {finding.file_path}:{finding.line_number}")
            report.append(f"   Confidence: {finding.confidence:.2f}")
            report.append(f"   Description: {finding.description}")
            report.append(f"   Evidence: {finding.evidence}")
            report.append(f"   Code:")
            for line in finding.code_snippet.split('\n'):
                report.append(f"     {line}")
            
            if finding.cve_matches:
                report.append(f"   Related CVEs: {len(finding.cve_matches)} found")
            
            if finding.suggested_patches:
                report.append(f"   Suggested Patches: {len(finding.suggested_patches)} available")
        
        return '\n'.join(report)

    def _generate_html_report(self, scan_result: ScanResult) -> str:
        """Generate HTML report"""
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Vulnerability Scan Report - {scan_result.scan_id}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background-color: #f0f0f0; padding: 20px; border-radius: 5px; }}
                .summary {{ margin: 20px 0; }}
                .finding {{ margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }}
                .critical {{ border-left: 5px solid #dc3545; }}
                .high {{ border-left: 5px solid #fd7e14; }}
                .medium {{ border-left: 5px solid #ffc107; }}
                .low {{ border-left: 5px solid #28a745; }}
                .code {{ background-color: #f8f9fa; padding: 10px; border-radius: 3px; font-family: monospace; }}
                .metadata {{ color: #666; font-size: 0.9em; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Vulnerability Scan Report</h1>
                <div class="metadata">
                    <p><strong>Scan ID:</strong> {scan_result.scan_id}</p>
                    <p><strong>Target:</strong> {scan_result.target_path}</p>
                    <p><strong>Timestamp:</strong> {scan_result.scan_timestamp}</p>
                    <p><strong>Duration:</strong> {scan_result.scan_duration:.2f} seconds</p>
                    <p><strong>Total Findings:</strong> {scan_result.total_findings}</p>
                </div>
            </div>
            
            <div class="summary">
                <h2>Summary by Severity</h2>
                <table border="1" style="border-collapse: collapse; width: 300px;">
                    <tr><th>Severity</th><th>Count</th></tr>
        """
        
        for severity, count in scan_result.findings_by_severity.items():
            html += f"<tr><td>{severity}</td><td>{count}</td></tr>"
        
        html += """
                </table>
            </div>
            
            <div>
                <h2>Detailed Findings</h2>
        """
        
        for i, finding in enumerate(scan_result.findings, 1):
            severity_class = finding.severity.lower()
            html += f"""
                <div class="finding {severity_class}">
                    <h3>{i}. {finding.vulnerability_type.upper()} - {finding.severity}</h3>
                    <p><strong>File:</strong> {finding.file_path}:{finding.line_number}</p>
                    <p><strong>Confidence:</strong> {finding.confidence:.2f}</p>
                    <p><strong>Description:</strong> {finding.description}</p>
                    <p><strong>Evidence:</strong> <code>{finding.evidence}</code></p>
                    <p><strong>Code:</strong></p>
                    <div class="code">{finding.code_snippet}</div>
            """
            
            if finding.cve_matches:
                html += f"<p><strong>Related CVEs:</strong> {len(finding.cve_matches)} found</p>"
            
            if finding.suggested_patches:
                html += f"<p><strong>Suggested Patches:</strong> {len(finding.suggested_patches)} available</p>"
            
            html += "</div>"
        
        html += """
            </div>
        </body>
        </html>
        """
        
        return html

# Example usage and testing
if __name__ == "__main__":
    # Initialize scanner with Scout Agent
    scout = ScoutAgent()
    scanner = VulnerabilityScanner(scout)
    
    # Populate knowledge base first
    print("Populating knowledge base...")
    scout.populate_knowledge_base(vuln_limit=5, patch_limit=3)
    
    # Scan the demo repository
    print("\nScanning demo repository...")
    scan_result = scanner.scan_directory("/Users/iamwafula/GitHub/upload-worker/Auto_Security/repo_demo")
    
    # Generate reports
    print("\nGenerating reports...")
    json_report = scanner.generate_report(scan_result, 'json')
    text_report = scanner.generate_report(scan_result, 'text')
    
    # Save reports
    with open('vulnerability_report.json', 'w') as f:
        f.write(json_report)
    
    with open('vulnerability_report.txt', 'w') as f:
        f.write(text_report)
    
    print(f"Scan completed: {scan_result.total_findings} findings found")
    print("Reports saved: vulnerability_report.json, vulnerability_report.txt")
